#!/bin/bash


# user settings

# specify your C compiler
GCC=gcc

# specify your C++ compiler
GPP=g++

# specify your Ruby interpreter
RUBY=ruby

# specify your Python interpreter
PYTHON=python

# end of user settings

if [ "$EVC" == "true" ]; then
  NC="\033[0m" # no color
  R="\033[0;31m" # red
  G="\033[0;32m" # green
  Y="\033[0;33m" # yellow
  GY="\033[0;37m" # light gray
fi

# find last modified .c, .cpp, .py or .rb file
source=$(ls -tr *.{c,cpp,rb,py} 2> /dev/null | tail -n -1)
# get file extension
extension=${source##*.}
# get file name
name=${source%.*}

# if no file found then cannot continue
if [ "$source" == "" ]; then
  printf "ev: no file for execution\n\n"
  exit
fi

echo " - $source -"

# if there is no 'test' directory
if [ ! -d "test/$name/" ]; then
  echo "* created test/$name/"
  mkdir -p "test/$name"
fi

# if check if tests exists
tests=$(ls "test/$name/$name".*.in 2> /dev/null)
if [ "$tests" == "" ]; then
  for case in {1..2}; do
    touch "test/$name/$name.$case.in"
    touch "test/$name/$name.$case.out"
    echo "* created test/$name/$name.$case.in"
    echo "* created test/$name/$name.$case.out"
  done
  echo
  exit
fi

# compile source
if [ "$extension" == "c" ]; then
  errors=$($GCC "$source" -o "$name" 2>&1> /dev/null)
elif [ "$extension" == "cpp" ]; then
  errors=$($GPP "$source" -o "$name" 2>&1> /dev/null)
fi

# if compile errors occured then cannot continue
if [ "$errors" != "" ]; then
  echo -e "${R}COMPILATION ERROR$NC"
  echo "$errors"
  echo
  exit
fi

hasCorrect=true
for fin in "test/$name/$name".*.in; do
  # from input file make output file with same format
  fout=${fin%.*}.out
  echo "* $fin:"

  if [ ! -s "$fin" ]; then
    echo "ev: file empty and skipped"
    echo
    continue
  fi

  ignore=false
  if [ -a "$fout" ] && [ "$(cat "$fout" | head -n 1 | cut -c 1)" == "!" ]; then
    ignore=true
  fi

  # if output file and is not empty exists user output is file
  if [ -a "$fout" ] && [ -s "$fout" ] && [ $ignore == false ]; then
    foutuser=${fin%.*}.user.out
  else
    foutuser="/dev/stdout" # user output it stdout
  fi

  # what file to execute
  execute=$source
  if [ "$extension" == "c" ] || [ "$extension" == "cpp" ]; then
    command="./"
    execute=$name
  elif [ "$extension" == "rb" ]; then
    command="$RUBY "
  else
    command="$PYTHON "
  fi

  # read line by line and send it to executing process
  while read line; do
    echo $line
  done < "$fin" | $command"$execute" > "$foutuser" &

  pid=$!

  # wait for redirect to finish - ignoring input time
  while ps -p $(($pid - 1)) > /dev/null; do continue; done;

  tle=false
  START=$(date +%s)
  while true; do
    getPID=$(ps | egrep "^[[:space:]]*${pid}")
    if [ "$getPID" != "" ]; then
      END=$(date +%s)
      DIFF=$(($END - $START))
      if [ "$DIFF" -gt "1" ]; then
        kill -SIGKILL $pid
        wait $! 2> /dev/null
        echo -e "${Y}TIME LIMIT EXCEEDED$NC"
        echo
        tle=true
        hasCorrect=false
        if [ "$foutuser" != "/dev/stdout" ]; then
          rm "$foutuser"
        fi
        break
      fi
    else
      break
    fi
  done

  if [ $tle == true ]; then
    continue
  fi

  if [ -a "$fout" ] && [ -s "$fout" ] && [ $ignore == false ]; then
    cmp -s "$fout" "$foutuser"
    if [ $? -eq 1 ]; then
      echo -e "${R}WRONG ANSWER$NC"
      echo -e "${GY}ev: check $foutuser for help$NC"
      hasCorrect=false
    else
      echo -e "${G}ACCEPTED$NC"
      rm "$foutuser"
    fi
  fi
  echo
done

if [ $hasCorrect == true ] && ([ "$extension" == "c" ] || [ "$extension" == "cpp" ]); then
  rm "$name" 2> /dev/null
fi
